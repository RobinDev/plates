<?php

declare (strict_types=1);

namespace League\Plates;

use League\Plates\Template\DoNotAddItInConstructorInterface;
use League\Plates\Template\Template;
use League\Plates\Template\TemplateClass;
use League\Plates\Template\TemplateClassInterface;
use PHP_CodeSniffer\Standards\Generic\Sniffs\NamingConventions\ConstructorNameSniff;
use PhpParser\Node\Param;
use PhpParser\Comment\Doc;
use PhpParser\Node;
use PhpParser\Node\Expr;
use PhpParser\Node\Name;
use PhpParser\Node\NullableType;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\UnionType;
use Rector\Core\NodeAnalyzer\ParamAnalyzer;
use Rector\Core\PhpParser\Printer\BetterStandardPrinter;
use Rector\Core\Rector\AbstractRector;
use Rector\Core\ValueObject\MethodName;
use Rector\NodeTypeResolver\NodeTypeResolver\ParamTypeResolver;
use Rector\Removing\NodeManipulator\ComplexNodeRemover;
use Rector\StaticTypeMapper\ValueObject\Type\FullyQualifiedObjectType;
use Rector\TypeDeclaration\NodeAnalyzer\CallTypesResolver;
use Symplify\RuleDocGenerator\ValueObject\CodeSample\CodeSample;
use Symplify\RuleDocGenerator\ValueObject\RuleDefinition;
/**
 * @see \Rector\Tests\DeadCode\Rector\ClassMethod\RemoveUnusedConstructorParamRector\RemoveUnusedConstructorParamRectorTest
 */
final class RectorizeTemplate extends AbstractRector
{
    const CLASS_TO_NOT_ADD_IN_CONSTRUCTOR = [Template::class, TemplateClass::class, DoNotAddItInConstructorInterface::class];


    /**
     * @readonly
     * @var ParamTypeResolver
     */
    private $paramTypeResolver;

    public function __construct(ParamTypeResolver $paramTypeResolver)
    {
        $this->paramTypeResolver = $paramTypeResolver;
    }
    public function getRuleDefinition() : RuleDefinition
    {
        return new RuleDefinition('Duplicate diplay to constructor except Template', [new CodeSample(<<<'CODE_SAMPLE'
final class SomeTemplate
{
    public function display(string $name, Template $t): void
    {
        // ...
    }
}
CODE_SAMPLE
, <<<'CODE_SAMPLE'
final class SomeClass
{
    public function display(string $name, Template $t): void
    {
        // ...
    }

    public function __construct(public string $name)
    {
    }
}
CODE_SAMPLE
)]);
    }
    /**
     * @return array<class-string<Node>>
     */
    public function getNodeTypes() : array
    {
        return [Class_::class];
    }

    /**
     * @param Class_ $node
     */
    public function refactor(Node $node) : ?Node
    {
        $implementedInterfaces = array_map( fn (Name $interface) => $interface->toString(), $node->implements );
        if (! in_array(TemplateClassInterface::class, $implementedInterfaces, true)) {
            return null;
        }

        $displayMethod = $node->getMethod('display') ;
        if ($displayMethod === null)
            return null;


        if ($displayMethod->params === [])
            return $this->removeConstructor($node);

        $paramsForConstructor = [];
        $docBlockForConstructor = [];
        $methodDocBlock = $displayMethod?->getDocComment()?->getText() ?? '';
        foreach($displayMethod->params as $parameter) {
            $paramType = $this->paramTypeResolver->resolve($parameter);
            if ($paramType instanceof FullyQualifiedObjectType
                && in_array($paramType->getClassName(), self::CLASS_TO_NOT_ADD_IN_CONSTRUCTOR, true)) {
                    continue;
            }

            $paramDocBlock = $this->getParameterDocblock($methodDocBlock, $this->getName($parameter));
            if ($paramDocBlock !== null)
                $docBlockForConstructor[] = $paramDocBlock;

            $cloneParameter = clone $parameter;
            $cloneParameter->flags = 1;

            if ($parameter->default instanceof Expr) {

                if (! $this->hasNullType($paramType) && $parameter->default instanceof \PhpParser\Node\Expr\ConstFetch && $this->hasNullValue($parameter)) {
                    $this->addTypeToParameter($cloneParameter, 'null');
                }
            }

            $paramsForConstructor[] = $cloneParameter;
        }

        if ($paramsForConstructor === [])
            return $this->removeConstructor($node);

        $constructor = $node->getMethod(MethodName::CONSTRUCT) ;
        $docBlockConstructor = $constructor?->getDocComment();
        $newDocBlockConstructor = new Doc("/**\n * ".trim("Autogenerated constructor\n * ".implode("\n * ", $docBlockForConstructor), "\n *")."\n*/");
        if ($paramsForConstructor === $constructor?->params || $docBlockConstructor === $newDocBlockConstructor) // TODO compare docblock
            return null;

        $this->removeConstructor($node);

        $constructor = new ClassMethod('__construct', [
            'flags' => Node\Stmt\Class_::MODIFIER_PUBLIC,
            'params' => $paramsForConstructor,
        ]);
        $constructor->setDocComment($newDocBlockConstructor);

        $node->stmts[] = $constructor;

        return $node;
    }

    private function hasNullType(\PHPStan\Type\Type $type):bool
    {
        if ($type instanceof \PHPStan\Type\NullType)
            return true;

        if ($type instanceof \PHPStan\Type\UnionType) {
            foreach($type->getTypes() as $type) {
                if ($this->hasNullType($type)) {
                    return true;
                }
            }
        }

        return false;
    }

    private function hasNullValue(Param $param): bool
    {
        $text = (new BetterStandardPrinter())->print($param);

        if (str_ends_with($text, 'null'))
            return true;

        return false;
    }

    private function removeConstructor(Class_ $class):null
    {
        foreach ($class->stmts as $key => $stmt) {
            if ($stmt instanceof Node\Stmt\ClassMethod && $stmt->name->toString() === MethodName::CONSTRUCT) {
                unset($class->stmts[$key]);
                break;
            }
        }

        return null;
    }

    private function getParameterDocblock(?string $methodDocblock, string $parameterName): ?string
    {
        if ($methodDocblock === null) {
            return null;
        }

        // Regular expression to match a docblock for a specific parameter
        $pattern = '/@param\s+[^$]*?\$'.$parameterName.'\b([^@]*)/';

        $patternIsFound = preg_match($pattern, $methodDocblock, $matches);

        if ($patternIsFound) {
            return trim($matches[0], '*/ '."\n");
        }

        return null;
    }


    private function addTypeToParameter( Param $param, string $type): void
    {

        $existingType = $this->nodeTypeResolver->getType($param);

        if ($existingType instanceof \PHPStan\Type\UnionType) {
            $existingTypes = $existingType->getTypes();
            $newTypes = [...$existingTypes, new \PHPStan\Type\NullType()];
            $param->type = new UnionType($newTypes);
            return;
        }

        if ( $existingType === null) {
            $param->type = new \PHPStan\Type\NullType();
            return;
        }

        //$param->type = new UnionType([$existingType, new \PHPStan\Type\NullType()]);

    }

}